<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Seshbot Programs]]></title>
  <link href="http://seshbot.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://seshbot.com/"/>
  <updated>2014-01-17T10:18:19+09:00</updated>
  <id>http://seshbot.com/</id>
  <author>
    <name><![CDATA[Paul Cechner]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Creating and deploying a Rails + Ember app]]></title>
    <link href="http://seshbot.com/blog/2014/01/15/creating-a-rails-plus-ember-app-from-scratch/"/>
    <updated>2014-01-15T17:54:16+09:00</updated>
    <id>http://seshbot.com/blog/2014/01/15/creating-a-rails-plus-ember-app-from-scratch</id>
    <content type="html"><![CDATA[<p>Today I decided to wield my new Rails and Ember knowledge and&hellip; look into yet another new technology. I thought it would be helpful to have an online app to demonstrate the fruits of my labours, so am deploying a new app to <strong><a href="http://heroku.com">Heroku</a></strong>.</p>

<p>Heroku is an &lsquo;application platform&rsquo; in the cloud, meaning that you can push certain kinds of apps (written in Ruby, Python, Java and Node.js) and it will ensure all the correct infrastructure is in place. When you sign up you get to host one app for free so it&rsquo;s easy to try out.</p>

<p>Later I will probably move to <a href="http://aws.amazon.com">Amazon Web Services</a>, which provides a basic virtual machine in the cloud that you can do anything with. This will allow me to host multiple applications without having to worry about paying money. Heroku <em>does</em> offer some pretty nice scaling, monitoring and deployment tools though (the admin panel literally has a slider to allow you to spin up new application instances.)</p>

<p>This post shows how I went through all steps, including setting up the PostgreSQL database on OSX, creating a skeleton Rails app, and deploying to Heroku. It is a culmination of having gone through several sources:</p>

<ul>
<li>much was taken from this useful step-by-step &lsquo;<a href="http://www.devmynd.com/blog/2013-3-rails-ember-js">Rails + Ember blog post</a>&rsquo; and this <a href="http://www.devmynd.com/blog/2013-10-live-on-the-edge-with-rails-ember-js">follow up post</a> that incorporates changes for newer versions of the frameworks.</li>
<li>when I got to the part involving installing the &lsquo;ember-rails&rsquo; gem, I found that the <a href="https://github.com/emberjs/ember-rails">ember-rails documentation</a> was pretty useful.</li>
<li>some of the Heroku stuff came from the <a href="https://www.codeschool.com/code_tv/heroku">Heroku Code School lesson</a> summary.</li>
</ul>


<!-- more -->


<h2>Choosing a database</h2>

<p>By default Rails will use sqlite3 for its database, and this isn&rsquo;t by default available in Heroku. As I&rsquo;m going to have to do some configuration anyway, I might as well choose a nicer database.</p>

<p>I was deciding between MongoDb and PostgreSQL. MongoDb offers flexibility when it comes to managing file assets in your database, while PostgreSQL is much more well established in existing hosting infrastructures (AWS and Heroku), so can make initial deployment much simpler. Mongo is also more amenable to schema changes because it&rsquo;s a NoSQL schema-less document database, but I think Rails is supposed to make schema changes easy anyway with the various <code>db:</code> commands.</p>

<p>As Heroku comes with PostgreSQL support out of the box, for now I&rsquo;ll go with Postgres. I&rsquo;m as yet not very familiar with Heroku and want to make things easier on myself.</p>

<p>The following installation instructions came from a blog entry on <a href="http://ricochen.wordpress.com/2012/07/20/install-postgres-on-mac-os-x-lion-with-homebrew-howto/">installing PostgreSQL on OSX with HomeBrew</a>:
```bash Installing PostgreSQL on  OSX</p>

<h1>easiest if you have homebrew installed</h1>

<p>brew install postgresql</p>

<h1>ensure it starts up when your machine starts</h1>

<p>ln -sfv /usr/local/opt/postgresql/*.plist ~/Library/LaunchAgents/homebrew.mxcl.postgresql.plist
launchctl load ~/Library/LaunchAgents/homebrew.mxcl.postgresql.plist</p>

<h1>ensure you don&rsquo;t accidentally run the older version</h1>

<p>echo &lsquo;export PATH=/usr/local/bin:$PATH&rsquo; >> ~/.bash_profile &amp;&amp; . ~/.bash_profile</p>

<h1>create a database user for the application to use</h1>

<h1>(alternatively you should be able to run &lsquo;createuser -d myapp&rsquo;)</h1>

<p>psql postgres <code>whoami</code>
create role myapp with CREATEDB login password &lsquo;password1&rsquo;;
```</p>

<p><em>Notes:</em></p>

<ul>
<li><em>the <code>createuser</code> command can replace the <code>psql</code> command stuff: <code>createuser -d myapp</code></em></li>
<li><em>if the DB username is different to the application name (below) you&rsquo;ll need to change the rails configuration later so it knows which username to use</em></li>
<li><em>I assume Heroku doesn&rsquo;t require you to manage the database at all</em></li>
</ul>


<h2>Creating a simple Rails app</h2>

<p>Creating a Rails app is really simple <em>once you know the commands</em>. So from scratch, if you include all the learning involved behind each command, it&rsquo;s actually not very simple. But these steps make it simple for me.</p>

<p>TIPS: I read somewhere that you should always run <code>bundle exec</code> before running a rails command to ensure that you&rsquo;re only working with gems in your Gemfile. Technically you could run all the commands below without prepending <code>bundle exec</code> however.</p>

<p><code>bash Creating the rails application framework
rails new myapp --database=postgresql
cd myapp
vim config/database.yml # set the database username and password, and on OSX un-comment the 'local' setting
bundle exec rake db:create    # create databases
bundle exec rails generate scaffold Thing name:string # generate model/views/controllers
bundle exec rake db:migrate   # update database with model data
bundle exec rails s           # start rails server localhost:3000
</code></p>

<p><em>Note: I had to uncomment the &lsquo;local&rsquo; setting from my </em>database.yml<em> file because rails couldn&rsquo;t connect due to permission problems on the local socket file. I could have reconfigured postgres instead but meh.</em></p>

<p>OSX users can also use <a href="http://pow.cx/">POW!</a> or <a href="http://anvilformac.com/">Anvil</a> (which uses POW! under the covers) to set up a fake URL pointing to their local rails app directories, so in my case I can visit <a href="http://myapp.dev">http://myapp.dev</a> and it will actually show me the app running on my local machine. It makes the testing cycle a lot quicker.</p>

<p>Add some simple static content:
```bash Generate some simple content in the Rails app
rails generate controller StaticPages home about &mdash;no-test-framework</p>

<h1>set root &lsquo;/&rsquo; route to point to static home page</h1>

<p>vim config/routes.rb # add &ldquo;root &lsquo;static_pages#home&rsquo;&rdquo; beneath other routes
```</p>

<p>Now you should be able to visit <code>localhost:3000</code> and see a generic &lsquo;home&rsquo; page message.</p>

<!-- x_ -->


<h3>Check in to git</h3>

<p>This creates a local git repository, but during the heroku deployment step I&rsquo;ll push it over there too. I&rsquo;ll also push it to GitHub when it looks like more of an app. So in git parlance, this is what I&rsquo;ll have on my local machine:</p>

<p><center><img src='/images/plantuml/7ff3365c0f4bc5f7e2db66419707938a.png'></center></p>

<p><code>bash Create the local 'master' git repository
rake tmp:clear
git init .
git add -f *
git commit -a -m"Initial commit"
</code></p>

<p>I regularly run those <code>git</code> commands to make it easier to revert any mistakes I happen to make.</p>

<h3>Adding ember framework</h3>

<p>I have tried two alternative approaches to creating a new rails app for ember.</p>

<h4>Alternative 1: use the ember &lsquo;edge template&rsquo;</h4>

<p>I think this one is probably the best as it was demonstrated by Yehuda Katz (main Ember guy) in <a href="http://www.youtube.com/watch?v=BpQj9_qEUAc">this live demonstration video</a>. I ran a diff on projects created with and without and it seems to:</p>

<ul>
<li>adds some ember gems to the Gemfile: <code>active_model_serializers</code>, <code>ember-rails</code> and <code>ember-source</code></li>
<li>remove the rails &lsquo;application view layout&rsquo; (<em>app/views/layouts/application.html.erb</em>)</li>
<li>create an ember &lsquo;application template&rsquo; (<em>app/assets/javascripts/templates/application.handlebars</em>)</li>
<li>creates a &lsquo;view asset&rsquo; that generates an index.html with the ember application.js in it (<em>app/views/assets/index.html.erb</em>)</li>
<li>sets up a rails route pointing to the assets controller &lsquo;index&rsquo; action (<em>config/routes.rb</em>)</li>
<li>create empty assets controller and helper files (not sure why)</li>
<li>create a rails ActiveModel &lsquo;application serializer&rsquo; (<em>app/serializers/application_serializer.rb</em>) that does a few things ember requires <!-- x_ --></li>
</ul>


<p>Installing using the edge template is simple. Just replace the <code>rails new</code> step above with the following:</p>

<p>```bash Creating a rails app using the ember template
rails new myapp &mdash;database=postgresql -m <a href="http://emberjs.com/edge_template.rb">http://emberjs.com/edge_template.rb</a>
cd myapp</p>

<h1>edit your database config and Gemfile as before&hellip;</h1>

<p>bundle exec rails g ember:bootstrap &mdash;javascript-engine js
bundle exec rails g ember:install &mdash;head
```</p>

<h4>Alternative 2: add ember to an existing rails app</h4>

<p>You could also just add the <code>ember-rails</code> gem directly to your Gemfile, then run <code>rails generate ember:bootstrap</code> and you get a basic Ember framework in your <code>app/assets</code> directory. I also prefer to use javascript directly (as opposed to CoffeeScript, which is the default), so add <code>-g --javascript-engine js</code></p>

<p>```bash Add a simple Ember application framework to the Rails app
vim Gemfile</p>

<h1>add &lsquo;gem &ldquo;ember-rails&rdquo;, github: &ldquo;emberjs/ember-rails&rdquo;&rsquo;</h1>

<p>```</p>

<p>Following this approach I believe you&rsquo;ll have to manually set up the <a href="https://github.com/rails-api/active_model_serializers">Ember ActiveModel Serializer</a> which was written by the Ember guys, and ensures your Ember app understands the format of your Rails app&rsquo;s JSON data. The first alternative does this for you.</p>

<h4>Common to both approaches</h4>

<p>After you have created and updated your Gemfile, you still need to bootstrap the ember environment, and then ensure Ember is running in &lsquo;development&rsquo; mode when Rails is.</p>

<p><em>Note: you can Set &lsquo;developer mode&rsquo; (which enables developer-centric error messages and is apparently quite useful) by updating your </em>config/environments/development.rb<em> with: <code>config.ember.variant = :development</code>. By default running locally will run in dev mode, and running on Heroku will run production mode however.</em></p>

<p>```bash Add a simple Ember application framework to the Rails app
bundle install
bundle exec rails g ember:bootstrap -g &mdash;javascript-engine js
bundle exec rails g ember:install &mdash;head</p>

<p>vim config/environments/development.rb # add config.ember.variant = :development
```</p>

<h2>Deploying to Heroku</h2>

<p>Heroku requires a few rails settings to be modified to work properly:</p>

<p>```bash Change rails app settings for Heroku
vim config/environments/production.rb # heroku runs in prod mode by default</p>

<h1>change &lsquo;config.serve_static_assets&rsquo; to true</h1>

<p>vim Gemfile</p>

<h1>add &ldquo;gem &lsquo;rails_12factor&rsquo;&rdquo;</h1>

<p>```</p>

<p>I have already gone through the Heroku sign up process and installed the toolbelt appropriate for OSX (the toolbelt provides the <code>heroku</code> command line tool), so I won&rsquo;t outline that here.</p>

<p>Installing my rails application on Heroku was then a simple matter of:</p>

<p>```bash Add application in the current directory to Heroku
heroku login
heroku create &mdash;stack cedar
git push heroku master</p>

<h1>whenever you make database changes</h1>

<p>heroku run rake db:migrate</p>

<h1>if you want to push your local database contents to heroku</h1>

<p>heroku db:push # requires the &lsquo;taps&rsquo; gem (&lsquo;gem install taps&rsquo;)
```</p>

<p>This creates an image with a particular configuration of applications and adds a <code>heroku</code> git remote to the git configuration.</p>

<p>Now you can visit the heroku app online (in my case at <a href="http://seshbot.herokuapp.com/">http://seshbot.herokuapp.com/</a>).</p>

<p>TODO: use <code>gem rails_12factor</code>? This alters the rails app a little to make it <a href="http://12factor.net/">12 factor</a>, which is a set of guidelines for how one should build an application to make it easier to administer and deploy. Not really important right now though.</p>

<!-- x_ -->


<h2>Troubleshooting and administering Heroku</h2>

<p><code>bash Various heroku debugging commands
heroku ps    # list running apps
heroku logs  # show application logs
heroku run console # run interactive ruby console
</code></p>

<p><code>bash Various heroku administrative commands
heroku config  # configure remote app through environment variables
heroku apps    # overview of apps
heroku destroy # deallocate remote server
heroku run rake db:migrate
</code></p>

<p><code>heroku config</code> sets environment variables for things you don&rsquo;t want to commit to git (e.g., passwords). Configure your Rails apps to use <code>ENV['MY_VAR']</code> instead of your super secret key, then run <code>heroku config:add MY_VAR=blahblah</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning Ruby and Rails]]></title>
    <link href="http://seshbot.com/blog/2014/01/14/learning-ruby-and-rails/"/>
    <updated>2014-01-14T10:32:29+09:00</updated>
    <id>http://seshbot.com/blog/2014/01/14/learning-ruby-and-rails</id>
    <content type="html"><![CDATA[<p><em>Note: The formatting of this article is not great, but I pumped it out quickly after going through the tutorials</em></p>

<p>I dedicated this morning to learning some Ruby and Ruby on Rails (RoR). For my purposes, RoR provides the server-side API to a web application, like this:</p>

<p><center><img src='/images/plantuml/ebdacec94fbe8fa7779a22a5718628cc.png'></center></p>

<p>To my delight, I quickly discovered that Ember (which I have been messing around with quite a bit) is modelled directly on Rails &ndash; not just in the generic they-are-both-MVC-architectures-way, but down to their usages being identical in many respects. I think many new webby techs follow this same style (Meteor seems to, for example.)</p>

<p>This post outlines the core concepts I have picked up from the various tutorials. I also included a RoR cheat-sheet I created while doing the Rails tutorial.</p>

<p>To get started on Windows/Mac, I&rsquo;m guessing the easiest way is by downloading the <a href="http://railsinstaller.org">RailsInstaller</a>.</p>

<!-- more -->


<h2>Learning Ruby</h2>

<p>For an absolute beginner, <a href="http://tryruby.org">Try Ruby</a> takes about 30 minutes, and will show the very basics:</p>

<ul>
<li>basic syntax</li>
<li>standard data structures (strings, arrays, hashes)</li>
<li>defining methods</li>
<li>defining classes (basics on attributes and <code>initialize</code> method)</li>
</ul>


<p>It stays very high-level, but obviously that&rsquo;s the intention. It avoids going into language features such as reflection, lambdas, string manipulation (<code>mystring = "var is #{my-var}"</code>), and doesn&rsquo;t talk about administration etc.</p>

<p>See the <a href="http://ruby-doc.org/core-2.1.0/">Ruby core documentation</a> for reference material.</p>

<h2>Learning Rails</h2>

<p>First, some language references: <a href="http://api.rubyonrails.org">Rails API docs</a> or <a href="http://apidock.com/rails">API Dock</a> or the other seachable <a href="http://railsapi.com">Rails API docs</a> can be downloaded and used locally.</p>

<p>I chose to follow the <a href="http://railsforzombies.org" title="">Rails for Zombies</a> tutorial, as it is often quoted as being helpful as a fully interactive online tutorial. It takes a few hours, but does seem to cover all the fundamentals, namely:</p>

<ul>
<li>Rails conventions

<ul>
<li>syntax for creation, read, update and delete of entities in the database</li>
<li>naming conventions for database table, view, and controller lookup</li>
</ul>
</li>
<li>Models

<ul>
<li>model class structure</li>
<li>invoking <abbr title="Create, Read, Update, Delete">CRUD</abbr> operations on the models</li>
<li>how relationships between entities are expressed, and how they map to the database structure</li>
</ul>
</li>
<li>Views

<ul>
<li>syntax (<code>&lt;% %&gt;</code> and <code>&lt;%= %&gt;</code>)</li>
<li>lookup from URL (searches <code>app/assets</code> folder before trying to run rails routes)</li>
<li>helpers (<code>link_to</code>, <code>edit_thing_path</code> etc)</li>
</ul>
</li>
<li>Controllers

<ul>
<li>controller class structure</li>
<li>rendering alternative views</li>
<li>rendering alternative formats (json, xml)</li>
<li>session variables (used for basic auth checks)</li>
<li>factoring out and configuring common code performed on all actions</li>
</ul>
</li>
<li>Routes

<ul>
<li>defining RESTful resources (automatically direct requests to controllers/views)</li>
<li>defining custom routes</li>
<li>creating helpers for <code>link_to</code> when creating custom routes</li>
</ul>
</li>
</ul>


<p>The main thing it <em>doesn&rsquo;t</em> cover is the administration (installation, deployment) and command-line usage (e.g., automatic generation of controllers and models.) This isn&rsquo;t a big deal however, as the <a href="http://guides.rubyonrails.org/getting_started.html">standard getting started guide</a> does this very well.</p>

<p>I think there are a few bugs in the programme however:</p>

<ul>
<li>the tutorial videos are a bit out of date (for pre-3.0 versions of RoR) but the practical exams use post-3.0 RoR it seems</li>
<li>the last prac exam requires different syntax than that in the tutorial:

<ul>
<li>redirect controller#action case is different (tut vids say <code>Zombies#undead</code> prac requires <code>zombies#undead</code>)</li>
<li>redirect in prac requires prefix &lsquo;/&rsquo; (&lsquo;/zombies => &rsquo;/undead'). Tutorial vids did not.</li>
</ul>
</li>
</ul>


<h3>Rails Cheat Sheet</h3>

<p>I created this while going through the Zombies tutorial. There&rsquo;s probably better cheat sheets out there, but I highly recommend creating your own as a learning experience.</p>

<h4>RoR&rsquo;s Ruby API syntax</h4>

<ul>
<li>Entity creation syntax (note, Rails will generate an ID for you):

<ul>
<li><code>t = Thing.new; t.status = "something"; t.save</code></li>
<li><code>t = Thing.new(:status =&gt; "something"); t.save</code></li>
<li><code>Thing.create(:status =&gt; "something")</code></li>
</ul>
</li>
<li>Entity query syntax:

<ul>
<li><code>Thing.find(1)</code> (by ID)</li>
<li>many alternate query methods: <code>first</code>, <code>last</code>, <code>all</code>, <code>count</code>, <code>order(:status)</code>, <code>limit(n)</code>, <code>where(:status =&gt; "good")</code></li>
<li>performance note: queries are performed on DB</li>
<li>syntax note: may also chain methods</li>
</ul>
</li>
<li>Entity update syntax:

<ul>
<li><code>t = Thing.find(id); t.status = "bad"; t.save</code></li>
<li><code>...; t.attributes = { :status =&gt; "bad"; ... }; save</code></li>
<li><code>...; t.update_attributes(:status =&gt; "bad"; ...}</code> (no save)</li>
</ul>
</li>
<li>Entity deletion syntax:

<ul>
<li><code>t = Thing.find(id); t.destroy</code></li>
<li><code>Thing.destroy_all</code></li>
</ul>
</li>
<li>on <code>save</code> failure, try <code>t.errors</code> to investigate what went wrong</li>
</ul>


<h4>Models</h4>

<p>Default model definition goes in <code>app/models/thing.rb</code></p>

<p>```ruby A simple model of a &lsquo;thing&rsquo; that has a &lsquo;status&rsquo; attribute
class Thing &lt; ActiveRecord::Base
   # validation
   #
   validates_presence_of :status # mandatory fields
   # many other validations: e.g., uniqueness, format, conf/acceptance, etc</p>

<p>   # alternative validation syntax:
   validates :status, :presence => true #, :length => { :minimum => 3 }</p>

<p>   # relationships (reflected in DB)
   #
   belongs_to :person
   # the Person will have &lsquo;has_many :things&rsquo; (note plural)
end
```</p>

<h4>Views</h4>

<ul>
<li><code>thing</code> default view definition goes in <code>app/views/things/index.html.erb</code> and <code>app/views/things/show.html.erb</code>):

<ul>
<li>alternatives actions to <code>show</code> can be added as <code>myaction.html.erb</code></li>
</ul>
</li>
<li>evaluate code with <code>&lt;% ruby code %&gt;</code>, eval and print with <code>&lt;%= ruby code %&gt;</code></li>
<li>shared application stuff (header/footer) goes in <code>app/views/layouts/application.html.erb</code> (use <code>&lt;%= yield %&gt;</code> for body placeholder)

<ul>
<li><code>&lt;%= stylesheet_link_tag :all %&gt;</code> renders stylesheet links for all files in <code>app/assets/stylesheets/</code></li>
<li><code>&lt;%= javascript_include_tag :defaults %&gt;</code> renders script tags for all files in <code>app/public/javascripts/</code></li>
<li>`&lt;%= csrf_meta_tag %> adds some stuff to prevent cross-site-meta-request-forgery hacking (people injecting their own HTML into comments etc)</li>
<li><code>&lt;%= link_to thing.name, thing_path(thing) %&gt;</code> (first param is link text, second URL). Can use the entity itself instead of <code>thing_path(thing)</code></li>
</ul>
</li>
</ul>


<p>Sample <code>index.html.erb</code> (create a link to this with <code>things_path</code>):
```erb An example &lsquo;things&rsquo; view template</p>

<ul>
<!-- @things set up in controller -->
<%= link_to "Home", root_path %>
<% if @things.empty? %>
   No things yet
<% else %>
   <% @things.each do |thing| %>
      <li>
         <%= link_to thing.status, thing %>
         <%= link_to "Edit", edit_thing_path(thing) %>
         <%= link_to "Delete", thing, :method => :delete %>
      </li>
   <% end %>
<% end %>
<%= link_to "+", new_thing_path %>
</ul>


<p>```</p>

<h4>Controllers</h4>

<ul>
<li><code>thing</code> controller definition goes in <code>app/controllers/things_controller.rb</code>_</li>
</ul>


<p>```ruby A &lsquo;things&rsquo; controller, responsible for setting view state
class ThingsController &lt; ApplicationController
   # common code, called by all actions
   before_filter :get_thing, :only => [:edit, :update, :destroy]
   before_filter :check_auth, :only => [:edit, :update, :destroy]</p>

<p>   def get_thing # called by before_filter</p>

<pre><code>  @thing = Thing.find(params[:id]) # all URL query params are available
</code></pre>

<p>   end</p>

<p>   def check_auth # called by before_filter</p>

<pre><code>  # do auth verification (check 'if flash[:notice]' in rendering page)
  if session[:user_id] != @thing.user_id
     # flash[:notice] = "Not authorized!" 
     redirect_to(things_path, :notice =&gt; "Not authorized!")
  end
</code></pre>

<p>   end</p>

<p>   def show         # show single</p>

<pre><code>  # set view state before rendering view

  render :action =&gt; 'myaction' # to render different view (default 'show')

  respond_to do |format| # optional
     format.html # myaction.html.erb
     format.xml { render :xml =&gt; @thing }
     format.json { render :json =&gt; @thing }
  end
</code></pre>

<p>   end</p>

<p>   def edit; end    # show &lsquo;edit&rsquo; form</p>

<p>   def index        # list all</p>

<pre><code>  if params[:status]
     @things = Thing.where(:status =&gt; params[:status])
  else
     @things = Thing.all
  end
</code></pre>

<p>   end</p>

<p>   def new; end     # show &lsquo;new&rsquo; form</p>

<p>   def create       # create new</p>

<pre><code>  # expects params of the form { thing: {status: 'good', name: 'xxx'} }
  @thing = Thing.create(params[:thing])

  redirect_to(@thing)
</code></pre>

<p>   end</p>

<p>   def update; end  # update</p>

<p>   def destroy; end # delete
end
```</p>

<h4>Routes</h4>

<ul>
<li>application routes defined in <code>app/config/routes.rb</code></li>
<li><code>resources</code> directive creates a full RESTful resource. This means that it will automatically create the following helpers and routes:

<ul>
<li><code>things_path</code> (/things &lsquo;index&rsquo; action)</li>
<li><code>thing</code> (/thing/id &lsquo;show&rsquo; action)</li>
<li><code>new_thing_path</code> (/things/new &lsquo;new&rsquo; action)</li>
<li><code>edit_thing_path(thing)</code> (/things/[id]/edit &lsquo;edit&rsquo; action)</li>
<li>&hellip; plus more</li>
</ul>
</li>
</ul>


<p>```ruby
MyApp::Application.routes.draw do
   resources :things</p>

<p>   match &lsquo;new_thing&rsquo; => &ldquo;Things#new&rdquo; # path => ControllerName=>actionName
   match &lsquo;all&rsquo; => &ldquo;Things#index&rdquo;, :as &ldquo;all_things&rdquo; # create all_things_path helper for link_to etc
   # alternative:
   match &lsquo;all&rsquo; => redirect(&lsquo;/things&rsquo;)</p>

<p>   # TODO: case sensitive? the tutorial seems confused on this
   root :to => &ldquo;Things#index&rdquo; # sets up &lsquo;/&rsquo; route to &lsquo;/things&rsquo;</p>

<p>   match &lsquo;status_things/:status&rsquo; => &lsquo;Things#index&rsquo; # add :status controller params
   match &lsquo;:username&rsquo; => &lsquo;Things#index&rsquo;, :as => &lsquo;user_things&rsquo;
   # in view: &lt;%= link_to &lsquo;seshbot things&rsquo;, user_things_path(&lsquo;seshbot&rsquo;) %>
end
```</p>
]]></content>
  </entry>
  
</feed>
